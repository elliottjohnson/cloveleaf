(uiop:define-package cloveleaf/smufl
  (:use #:cl #:com.inuoe.jzon #:cloveleaf))
(in-package #:cloveleaf/smufl)

(defvar *smufl-metadata-directory-pathname*
  nil
  "A default pathname to use for the SMuFL metadata.")

(defparameter +smufl-metadata-glyphnames-filename+
  "glyphnames.json"
  "The filename of the SMuFL glyphnames.json file to read in.")
(defparameter +smufl-metadata-classes-filename+
  "classes.json"
  "The filename of the SMuFL classes.json file to read in.")
(defparameter +smufl-metadata-ranges-filename+
  "ranges.json"
  "The filename of the SMuFL ranges.json file to read in.")

(defun generate-smufl-metadata-files (&key (source-directory *smufl-metadata-directory-pathname*)
					(glyphnames-json +smufl-metadata-glyphnames-filename+)
					(classes-json +smufl-metadata-classes-filename+)
					(ranges-json +smufl-metadata-ranges-filename+)
					(glyphnames-lisp +cloveleaf-glyphnames-filename+)
					(classes-lisp +cloveleaf-classes-filename+)
					(ranges-lisp +cloveleaf-ranges-filename+)
					(destination-directory *cloveleaf-source-directory-pathname*))
  "Reads in the SMuFL Specification Metadata and re-writes as a set of lisp objects."
  (generate-glyphnames :srcdir source-directory
		       :filename glyphnames-json
		       :outfile glyphnames-lisp
		       :outdir destination-directory)
  (let ((glyphs (read-glyphnames (merge-pathnames glyphnames-lisp destination-directory))))
    (generate-classes :srcdir source-directory
		      :filename classes-json
		      :outfile classes-lisp
		      :outdir destination-directory
		      :glyphs glyphs)))

;;; We want to read in the SMuFL distributed files and emit lisp forms
;;; that will be used for our purposes.  First we look at emitting
;;; the glyphnames.json file.  The definition of a glyph exists in the
;;; clovetree source code, so the emitted code will need to sync with the
;;; class definition over there.

(defgeneric emit (object stream)
  (:documentation
   "A method used to write OBJECT to STREAM in a way that the main program can read.")
  (:method ((object glyph) (stream stream))
    (with-accessors ((name glyph-name)
		     (code glyph-code)
		     (description glyph-description)
		     (alternates glyph-alternates))
	object
      (fresh-line stream)
      (write `(:name ,name
	       :code ,code
	       :description ,description
	       :alternates ,(glyph-list-to-characters alternates))
	     :stream stream)))
  (:method ((object classes) (stream stream))
    (with-accessors ((name classes-name)
		     (glyphs classes-glyphs))
	object
      (fresh-line stream)
      (write `(:name ,name
	       :glyphs ,(glyph-list-to-characters glyphs))
	     :stream stream)))
  (:method ((object ranges) (stream stream))
    (with-accessors ((name ranges-name)
		     (description ranges-description)
		     (end ranges-end)
		     (start ranges-start)
		     (glyphs ranges-glyphs))
	object
      (fresh-line stream)
      (write `(:name ,name
	       :description ,description
	       :end ,end
	       :start ,start
	       :glyphs ,(glyph-list-to-characters glyphs))
	     :stream stream))))

;;;
;;; SMuFL glyphnames.json
;;;

(defun generate-glyphnames (&key (srcdir *smufl-metadata-directory-pathname*)
			      (filename +smufl-metadata-glyphnames-filename+)
			      (outfile +cloveleaf-glyphnames-filename+)
			      (outdir *cloveleaf-source-directory-pathname*))
  "Does the actual work of parsing the JSON file into glyphs and writting them as lisp readable data to file."
  (let ((output-file (merge-pathnames outfile outdir)))
    (with-parser (parser (merge-pathnames filename srcdir))
      (parse-next parser)	    ; pop off the first :begin-object.
      (with-open-file (file output-file
			    :direction :output
			    :if-does-not-exist :create)
	(print-header file)
	(loop for glyph = (parse-glyph parser)
	      while glyph
	      do (emit glyph file))
	(fresh-line file)))
    output-file))

(defun glyph-list-to-characters (glyph-list)
  "Converts a LIST of GLYPHs to a list of characters.  Accepts lists of glyphs, unicode integer codes, or characters."
  (assert (listp glyph-list))
  (loop for glyph in glyph-list
	collect (cond ((numberp glyph) (code-char glyph))
		      ((glyphp glyph) (glyph-character glyph))
		      ((characterp glyph) glyph)
		      (t (error "Unknown glyph reference type: ~S" glyph)))))

(defun print-header (stream)
  "Prints a header for auto generated files."
  (format stream "~%;;; Autogenerated by cloveleaf based upon SMuFL spec files.~%"))

(defun parse-glyph (parser)
  "Parses the JSON for an individual glyph and returns either a glyph object or NIL."
  (assert (typep parser 'parser))
  (multiple-value-bind (key glyphname)
      (parse-next parser)		; we are done parsing glyphs.
    (unless (or (eq :end-object key) 
		(null key)
		(null glyphname))
      (unless (and (eq key :object-key)
		   (stringp glyphname))
	(error "Parsing glyph name: ~S and ~S" key glyphname))
      (let ((glyph (make-instance 'glyph :name glyphname)))
	(parse-glyph-body parser glyph)
	glyph))))

(defun %object-keyp (key value keystring)
  "Matches a value to a keystring."
  (and (eq :object-key key)
       (stringp value)
       (string= value keystring)))

(defun %string-valuep (key value)
  "Returns true if key equals :VALUE and the value is a string."
  (and (eq :value key) (stringp value)))

(defmacro json-key-value-match ((parser key-sym value-sym) &rest form)
  `(multiple-value-bind (,key-sym ,value-sym)
       (parse-next ,parser)
     (when (%string-valuep ,key-sym ,value-sym)
       ,@form)))

(defun parse-glyph-body (parser glyph)
  "Parses the body of a GLYPH from JSON"
  (assert (typep parser 'parser))
  (assert (typep glyph 'glyph))
  (unless (eq :begin-object (parse-next parser))
    (error "Failed to find start of glyph object."))
  (with-accessors ((code glyph-code)
		   (description glyph-description)
		   (alternates glyph-alternates))
      glyph
    (loop for (key value) = (multiple-value-list (parse-next parser))
	  while (not (eq :end-object key))
	  do (cond ((%object-keyp key value "codepoint")
		    (json-key-value-match (parser k v) (setf code (codepoint-code v))))
		   ((%object-keyp key value "description")
		    (json-key-value-match (parser k v) (setf description v)))
		   ((%object-keyp key value "alternateCodepoint")
		    (json-key-value-match (parser k v)
					  (setf alternates (list (codepoint-code v)))))
		   (t (error "Unknown key '~S' and value '~S' in parsing glyph body."
			     key
			     value))))))

(defun codepoint-code (code-point)
  "Converts hexidecimal string codepoints into integers."
  (assert (stringp code-point))
  (parse-integer (string-left-trim "U+" code-point) :radix 16))

;;;
;;; SMuFL classes.json
;;;

(defun generate-classes (&key (srcdir *smufl-metadata-directory-pathname*)
			   (filename +smufl-metadata-classes-filename+)
			   (outfile +cloveleaf-classes-filename+)
			   (outdir *cloveleaf-source-directory-pathname*)
			   glyph-table)
  "Does the actual work of parsing the JSON file into classes and writing them as lisp readable data to file."
  (assert (hash-table-p glyph-table))
  (let ((output-file (merge-pathnames outfile outdir)))
    (with-parser (parser (merge-pathnames filename srcdir))
      (parse-next parser)	     ; pop off the first :begin-object
      (with-open-file (file output-file
			    :direction :output
			    :if-does-not-exist :create)
	(print-header file)
	(loop for classes = (parse-classes parser glyph-table)
	      while classes
	      do (emit classes file))
	(fresh-line file)
	output-file))))

(defun parse-classes (parser glyph-table)
  "Parses the JSON for an individual SMuFL class definition and returns either a CLASSES object or NIL."
  (assert (typep parser 'parser))
  (assert (hash-table-p glyph-table))
  (multiple-value-bind (key classname)
      (parse-next parser)
    (unless (or (eq :end-object key)
		(null key)
		(null classname))
      (unless (and (eq key :object-key)
		   (stringp classname))
	(error "Parsing class name: ~S and ~S" key classname))
      (let ((classes (make-instance 'classes :name classname)))
	(parse-classes-body parser classes glyph-table)
	classes))))

(defun parse-classes-body (parser classes glyph-table)
  (assert (typep parser 'parser))
  (assert (typep classes 'classes))
  (assert (hash-table-p glyph-table))
  (unless (eq :begin-array (parse-next parser))
    (error "Failed to find expected classes array!"))
  (with-accessors ((glyphs classes-glyphs))
      classes
    (loop for (key value) = (multiple-value-list (parse-next parser))
	  while (not (eq :end-array key))
	  do (if (and (eq :value key)
		      (stringp value))
		 (push (find-glyph-by-name glyph-table value :error-p t)
		       glyphs)
		 (error "Failed to find classes glyph array element!")))))

(defun find-glyph-by-name (glyph-table name &key error-p)
  "Loops over all glyphs in GLYPH-TABLE and returns a matching glyph."
  (let ((glyph (loop for g being the hash-value in glyph-table
		     when (string= (glyph-name g) name)
		     return g)))
    (if (and (not glyph) error-p)
	(error "Unable to locate glyph: ~S in hash-table: ~S" name glyph-table)
	glyph)))

;;;
;;; SMuFL ranges.json
;;;

(defun generate-ranges (&key (srcdir *smufl-metadata-directory-pathname*)
			  (filename +smufl-metadata-ranges-filename+)
			  (outfile +cloveleaf-ranges-filename+)
			  (outdir *cloveleaf-source-directory-pathname*)
			  glyph-table)
  "Does the actual work of parsing the JSON file into ranges and writting them as lisp readable data to file."
  (assert (hash-table-p glyph-table))
  (let ((output-file (merge-pathnames outfile outdir)))
    (with-parser (parser (merge-pathnames filename srcdir))
      (parse-next parser)	     ; pop off the first :begin-object
      (with-open-file (file output-file
			    :direction :output
			    :if-does-not-exist :create)
	(print-header file)
	(loop for range = (parse-range parser glyph-table)
	      while range
	      do (emit range file))
	(fresh-line file)))
    output-file))

(defun parse-range (parser glyph-table)
  "Parses the JSON for an individual SMuFL range definition and returns either a RANGES object or NIL."
  (assert (typep parser 'parser))
  (assert (hash-table-p glyph-table))
  (multiple-value-bind (key rangename)
      (parse-next parser)
    (unless (or (eq :end-object key)
		(null key)
		(null rangename))
      (unless (and (eq key :object-key)
		   (stringp rangename))
	(error "Parsing range name: ~S and ~S" key rangename))
      (let ((ranges (make-instance 'ranges :name rangename)))
	(parse-ranges-body parser ranges glyph-table)
	ranges))))

(defun parse-ranges-body (parser ranges glyph-table)
  "Parses the body of a RANGES object from JSON."
  (assert (typep parser 'parser))
  (assert (typep ranges 'ranges))
  (assert (hash-table-p glyph-table))
  (unless (eq :begin-object (parse-next parser))
    (error "Failed to find expected ranges object!"))
  (with-accessors ((description ranges-description)
		   (start ranges-start)
		   (end ranges-end))
      ranges
    (loop for (key value) = (multiple-value-list (parse-next parser))
	  while (not (eq :end-object key))
	  do (cond ((%object-keyp key value "description")
		    (json-key-value-match (parser k v) (setf description v)))
		   ((%object-keyp key value "glyphs")
		    (parse-ranges-glyphs parser ranges glyph-table))
		   ((%object-keyp key value "range_start")
		    (json-key-value-match (parser k v) (setf start v)))
		   ((%object-keyp key value "range_end")
		    (json-key-value-match (parser k v) (setf end v)))
		   (t (error "Unknown key '~S' and value '~S' in parsing ranges body!"
			     key
			     value))))))

(defun parse-ranges-glyphs (parser ranges glyph-table)
  "Parses a list of glyphs associated with a range."
  (assert (typep parser 'parser))
  (assert (typep ranges 'ranges))
  (assert (hash-table-p glyph-table))
  (unless (eq :begin-array (parse-next parser))
    (error "Failed to find expected glyph array for SMuFL range!"))
  (with-accessors ((glyphs ranges-glyphs))
      ranges
    (loop for (key value) = (multiple-value-list (parse-next parser))
	  while (not (eq :end-array key))
	  do (if (and (eq :value key)
		      (stringp value))
		 (push (find-glyph-by-name glyph-table value :error-p t)
		       glyphs)
		 (error "Failed to find ranges glyph array element!")))))
